# 2장 개략적인 규모 추정

개략적인 규모 추정은 **보편적으로 통용되는 성능 수치상에서 사고 실험(thought experiments)을 행하여 추정치를 계산하는 행위**로서, 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것.

이를 위해서는 규모 확장성을 표현하는 데 필요한 기본기를 갖고 있어야 합니다.

- 2의 제곱수
- 응답지연 값
- 가용성에 관계된 수치.

# 2의 제곱수

ASCII 문자 하나가 차지하는 메모리 크기가 1Byte입니다.

비트는 0또는 1로만 표현할 수 있는 디지털 표현의 최소 단위입니다.

![비트와 바이트](https://github.com/BE-Protier/BE-Protier/assets/71534899/b8ca3b18-4cf5-4d42-826d-3752fab54b8f)

컴퓨터를 처음 개발한 영미권에서 알파벳 대소문자 a-Z, 숫자 0-9, 기타 기호를 표현하기 위해서 비트 8개를 묶어서 Byte(바이트)라고 정의 하였습니다. 1Byte는 8개의 bit가 모여서 정의되는데 이에 따라 2^8 즉, 256개의 값을 표현할 수 있습니다. 메모리와 저장장치의 공간을 계산할 때 Byte가 기본 단위가 됩니다.

![데이터 단위](https://github.com/BE-Protier/BE-Protier/assets/71534899/0428be68-c38c-45be-b641-98921c9d1521)

# 응답 지연 값

컴퓨터 연산들의 처리 속도가 어느정도 짐작하기 위해서는 응답 지연 값에 대한 개념은 알고 있어야 합니다.

![응답지연값](https://github.com/BE-Protier/BE-Protier/assets/71534899/8ab4bc38-fd2b-4214-9d19-e78a7942b3a7)

위의 표를 시각화한 자료는 다음과 같습니다.

![응답 지연값 시각화](https://github.com/BE-Protier/BE-Protier/assets/71534899/5f284b71-f589-4928-8d65-116f3477c7ba)

이 자료를 정리하면 다음과 같습니다.

- 메모리는 빠르지만 디스크는 아직 느리다.
- 디스크 탐색은 가능한 한 피하라 ( 2,000,000ns, 2ms의 시간이 걸리는 것으로 굉장히 많은 시간이 걸림 )
- 단순한 압축 알고리즘은 빠르다.
- 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.
- 데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 오래 걸린다.

이 응답 지연값에 대한 개념을 바탕으로 데이터베이스(디스크)에 대한 접근과 메모리(캐시)에 대한 접근의 응답 지연을 추정해볼 수 있습니다. 우선 이에 앞서서 간단하게 디스크와 메모리에 대한 개념을 다음과 같습니다.

## 디스크와 메모리

메모리는 컴퓨터의 RAM(Random Access Memory)를 의미하며, 데이터를 일시적으로 저장합니다. 메모리는 빠른 속도로 데이터에 접근할 수 있으나, 전원이 꺼지면 저장된 데이터가 사라지는 휘발성을 가집니다.

반면, 디스크는 HDD(Hard Disk Drive)나 SSD(Solid State Drive)와 같은 저장 장치를 말하며, 데이터를 영구적으로 저장합니다. 디스크는 비휘발성이지만, 메모리에 비해 데이터 접근 속도가 느립니다.

왜냐하면 메모리는 CPU와의 직접적인 연결을 통해 빠른 데이터 처리를 가능하게 하지만, 디스크는 물리적인 읽기/쓰기 작업을 필요로 하기 때문입니다.

## 디스크 접근과 메모리 접근에 대한 응답 지연 시간 비교

### **메모리 접근 시간**

- L1 캐시 참조: 1ns
- L2 캐시 참조: 4ns
- 주 메모리 참조: 100ns
- 메모리에서 1,000,000Byte ( 1MB ) 순차적 읽기: 1,000ns ≈ 1μs

### **데이터베이스 접근 시간**

- 디스크 탐색 (seek): 2,000,000ns ≈ 2ms
- 디스크에서 1,000,000Byte ( 1MB ) 순차적으로 읽기: 474,000ns ≈ 474μs

위의 표에서 알 수 있듯이, 메모리 접근 시간과 디스크 접근 시간에는 큰 차이가 있습니다.

1. **캐시 접근**: L1 캐시 참조는 1ns, L2 캐시 참조는 4ns입니다. 이는 매우 짧은 시간으로, 프로세서가 캐시에 저장된 데이터를 매우 빠르게 접근할 수 있음을 의미합니다.
2. **주 메모리 접근**: 주 메모리 참조는 100ns입니다. 이는 캐시 접근보다는 느리지만 여전히 매우 빠릅니다. 주 메모리는 DRAM(Dynamic RAM)으로 구성되며, 전기 신호를 이용해 데이터를 저장하고 읽어내는 방식입니다.
3. **디스크 접근**: 디스크 탐색 시간은 2,000,000ns ≈ 2ms이며, 디스크에서 1 MB를 순차적으로 읽는 시간은 474,000ns ≈ 474μs입니다. 이는 메모리 접근 시간과 비교할 때 매우 큰 차이가 있습니다. 디스크는 일반적으로 HDD(Hard Disk Drive)를 의미하며, 이는 물리적인 디스크 회전과 읽기/쓰기 헤드의 이동을 필요로 하므로 접근 시간이 매우 깁니다.

# 고가용성

**고가용성**은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력을 지칭합니다.

- 고가용성을 표현하는 값은 **퍼센트(%)로 표현합니다.**
- **100%**는 **시스템이 단 한 번도 중단된 적이 없었음**을 의미한다.
- 대부분의 서비스는 99%에서 100% 사이의 값을 갖는다.

  **SLA(Service Level Agreement)**는 서비스 사업자가 보편적으로 사용하는 용어로, **서비스 사업자와 고객 사이에 맺어진 합의**를 의미한다.

- 이 합의에는 **서비스 사업자가 제공하는 서비스의 가용시간이 공식적으로 기술**되어 있다.
- 아마존, 구글, 마이크로소프트 같은 사업자는 99% 이상의 SLA를 제공한다.
- **가용시간은 관습적으로 숫자 9를 사용해 표시한다.**
- **9가 많으면 많을수록 좋다고 생각하면 된다.
  다음 표를 보면 9가 많아질 수록 장애시간이 점점 줄어드는 것을 확인할 수 있다.**

![고가용성](https://github.com/BE-Protier/BE-Protier/assets/71534899/93a15298-70d0-4f62-b11d-ef29d90913d6)

고가용성 환경의 경우 고가용성 아키텍처가 목표를 충족하는지 여부를 판단하기 위해 IT 팀은 몇 가지 일반적인 메트릭도 사용합니다. 기준 성능 기대치를 설정하려면 다음의 메트릭을 모두 평가해보는 것이 좋습니다.

- **평균 장애 간격(MTBF)**: 시스템 장애 발생 시점부터 다음 장애 발생 시점까지 환경이 작동하는 평균 시간
- **평균 다운타임**: 시스템이 토폴로지에서 복구 또는 교체되기 전까지 작동하지 않는 평균 시간(다운타임 시간(단위: 분))
- **복구 시간 목표(RTO)**: 수리를 완료하고 시스템을 다시 온라인 상태로 복구하는 데 걸리는 총 시간
- **복구 지점 목표(RPO)**: 데이터를 복구할 수 있어야 하는 기간. 데이터가 손실된 기간을 뜻합니다. 예를 들어, 시스템이 백업에서 다른 시스템을 가져와야 하며 백업이 매일 이루어지는 경우 복구된 시스템에서 최대 24시간 동안의 데이터가 손실될 수 있습니다. 그러나 복제되거나 공유된 스토리지가 있으면 데이터 손실 시간은 몇 분밖에 되지 않거나 그 이하일 수 있습니다.
- QPS ( Query per second ): 데이터베이스나 웹 서버 API 등에서 특정 작업이나 **요청이 초당으로 얼마나 처리**되는지를 나타내는 지표입니다. 이는 시스템의 **성능과 처리 능력을 평가하는 중요한 측정 지표** 중 하나입니다.

**예시: 데이터베이스의 QPS 추정**

    ### **가정**

    - 데이터베이스 쿼리의 평균 응답 시간이 250ms입니다.
    - 데이터베이스 서버는 동시에 20개의 쿼리를 처리할 수 있습니다.

    ### **계산**

    1. **평균 응답 시간**: 250ms = 0.25초 ( 1000ms = 1초 )
    2. **초당 한 개의 쿼리를 처리할 수 있는 수**: 0.251=4

        10.25=4

    3. **병렬 처리 수**: 20

    따라서, 데이터베이스 서버의 QPS는:

    𝑄𝑃𝑆=1평균 응답 시간×병렬 처리 수*QPS*=평균 응답 시간1×병렬 처리 수𝑄𝑃𝑆=4×20=80*QPS*=4×20=80

    이 데이터베이스 서버는 초당 80개의 쿼리를 처리할 수 있습니다.
